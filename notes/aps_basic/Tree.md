## 트리

### 트리

- 트리 개념

  - 비선형 구조

  - 원소들 간에 1:n 관계를 가지는 자료구조

  - 계층형 자료구조

  - 하위 원소로 내려가면서 확장되는 트리모양의 구조

  - 한 개 이상의 노드로 이루어진 유한 집합

- 용어 정리

  - 루트 노드(root node): 노드 중 최상위 노드. 트리의 시작 노드

  - 형제 노드: 같은 부모 노드의 자식 노드들

  - 조상 노드: 간선을 따라 루트 노드까지 이르는 경로에 있는 모든 노드들

  - 서브 트리: 부모 노드와 연결된 간선을 끊었을 때 생성되는 트리

  - 자손 노드: 서브 트리에 있는 하위 레벨의 노드들

  

  - 노드의 차수: 노드에 연결된 자식 노드의 수
  - 트리의 차수: 트리에 있는 노드의 차수 중에서 가장 큰 값
  - 단말 노드: 차수가 0인 노드. 자식 노드가 없는 노드
  - 노드의 높이: 루트에서 노드에 이르는 간선의 수. 노드의 레벨



### 이진 트리

모든 노드들이 2개의 서브트리를 갖는 형태의 트리

각 노드가 자식 노드를 최대 2개까지만 가질 수 있는 트리

- 이진 트리의 특성

  레벨 i에서의 노드의 최대 개수는 2^i 개

  높이가 h인 이진 트리가 가질 수 있는 노드의 최소 개수는 (h+1)개가 되며 최대 개수는 2^(h+1)-1 개가 된다.

- 이진 트리의 종류

  - 포화 이진 트리

    모든 레벨에 노드가 포화상태로 차있는 이진 트리

    루트를 1번으로 하여 2^(h+1)-1 까지 정해진 위치에 대한 노드 번호를 가짐

  - 완전 이진 트리

    높이가 h이고 노드 수가 n개일 때, 포화 이진 트리의 노드 번호 1번부터 n번까지 빈 자리가 없는 이진 트리

  - 편향 이진 트리

    높이 h에 대한 최소 개수의 노드를 가지면서 한쪽 방향의 자식 노드만을 가진 이진 트리

- 순회(traversal)

  순회란 트리의 각 노드를 중복되지 않게 전부 방문하는 것을 말한다. 트리는 비선형 구조이기 때문에 선형구조에서와 같이 선후 연결 관계를 알 수 없다.

  따라서 다음과 같은 방법 존재
  
  - 전위 순회(preorder traversal): VLR

    부모노드 방문 후, 자식 노드 좌우 순서로 방문(노드의 왼쪽에 점을 찍고 따라가면 편함)

  - 중위 순회(inorder traversal): LVR
  
    왼쪽 자식노드, 부모노드, 오른쪽 자식노드 순으로 방문(노드의 아래에 점을 찍고 따라가면 편함)
  
  - 후위 순회(postorder traversal): LRV
  
    자식노드를 좌우 순서로 방문한 후, 부모노드 방문(노드의 오른쪽에 점을 찍고 따라가면 편리함)

  
  
  ```python
  # 전위 순회
  def preorder_traverse(T):
      if T:
          dosomething(T)     # print
          preorder_traverse(T.left)
          preorder_traverse(T.right)
  ```
  
  ```python
  # 중위 순회
  def inorder_traverse(T):
      if T:
          inorder_traverse(T.left)
          dosomething(T)
          inorder_traverse(T.right)
  ```
  
  ```python
  # 후위 순회
  def postorder_traverse(T):
      if T:
          postorder_traverse(T.left)
          postorder_traverse(T.right)
          dosomething(T)
  ```



- 배열을 이용한 이진 트리의 표현

  노드 번호가 i인 노드의 부모 노드 번호: i/2

  노드 번호가 i인 노드의 왼쪽 자식 노드 번호는: 2*i

  노드 번호가 i인 노드의 오른쪽 자식 노드 번호: 2*i+1

  레벨 n의 시작 노드 번호: 2^n

  

  높이가 h인 이진 트리를 위한 배열의 크기는? 2^(h+1)-1

  ```python
  c = 5    # 5번 노드 c의 조상찾기
  anc = []
  while par[c] != 0:
      anc.append(par[c])
      c = par[c]
  print(*anc)
  ```

  

  - 배열을 이용한 이진 트리 표현의 단점

    편향 이진 트리의 경우, 사용하지 않는 배열 원소에 대한 메모리 공간 낭비 발생

    트리의 중간에 새로운 노드를 삽입하거나 기존의 노드를 삭제할 경우 배열의 크기 변경이 어려워 비효율적

    ⇒ 이러한 단점을 보완하기 위해 연결리스트를 이용하여 트리를 표현

  

- 수식 트리

  수식을 표현하는 이진 트리

  수식 이진 트리라고 부르기도함

  연산자는 루트 노드이거나 가지 노드

  피연산자는 모두 잎 노드

  

### 이진 탐색 트리

탐색 작업을 효율적으로 하기 위한 자료구조

모든 원소는 서로 다른 유일한 키를 갖는다.

key(왼쪽 서브트리) < key(루트 노드) < key(오른쪽 서브트리)

중위 순회하면 오름차순으로 정렬된 값을 얻을 수 있음

- 탐색 연산

  루트에서 시작한다

  (키 값 x < 루트노드의 키 값) 인 경우: 루트노드의 왼쪽 서브트리에 대해서 탐색연산 수행

  (키 값 x > 루트노드의 키 값) 인 경우: 루트노드의 오른쪽 서브트리에 대해서 탐색연산 수행

- 삽입 연산



탐색, 삽입, 삭제 시간은 트리의 높이 만큼 시간이 걸린다.

- 평균의 경우: 이진트리가 균형적으로 생성되어 있는 경우. O(log n)
- 최악의 경우: 한쪽으로 치우친 경우. O(n)



### 힙

완전 이진 트리에 있는 노드 중에서 키값이 가장 큰 노드나 키값이 가장 작은 노드를 찾기 위해 만든 자료구조(중복된 값 허용)

- 최대 힙

  키값이 가장 큰 노드를 찾기 위한 완전 이진 트리

  루트 노드: 키값이 가장 큰 노드

- 최소 힙

  키값이 가장 작은 노드를 찾기 위한 완전 이진 트리

  루트 노드: 키값이 가장 작은 노드

```python
# 최대힙
def enq(n):
    global last
    last += 1
    tree[last] = n
    c = last
    p = c//2
    while p>=1 and tree[p] < tree[c]:
        tree[p], tree[c] = tree[c], tree[p]
        c = p
        p = c//2
tree = [0]*101
last = 0
```

- 힙 연산 - 삽입

- 힙 연산 - 삭제

  힙에서는 루트 노드의 원소만을 사용할 수 있다.