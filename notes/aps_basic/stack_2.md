## stack_2

### 계산기

- 문자열 수식 계산의 일반적 방법

  step1. 중위 표기법의 수식을 후위 표기법으로 변경(스택 이용)

  (중위표기법: 연산자를 피연산자의 가운데 표기하는 방법)

  step2. 후위 표기법의 수식을 스택을 이용하여 계산

  (후위표기법: 연산자를 피연산자 뒤에 표기하는 방법)

  

- 중위표기식을 후위표기식으로 변환하는 방법1

  수식의 각 연산자를 우선순위에 따라 괄호를 사용하여 다시 표현

  → 각 연산자를 그에 대응하는 오른쪽 괄호의 뒤로 이동

  → 괄호 제거

- 중위표기식을 후위표기식으로 변환하는 방법2(스택 이용)

  입력 받은 중위 표기식에서 토큰을 읽는다

  → 토큰이 피연산자이면 토큰을 출력

  → 토큰이 연산자(괄호 포함)일 때, 이 토큰이 스택의 top에 저장되어 있는 연산자보다 우선순위가 높으면 스택에 push하고, 그렇지 않으면 스택 top의 연산자의 우선순위가 토큰의 우선순위보다 작을 때까지 스택에서 pop 한 후, 토큰의 연산자를 push한다. (만약 top에 연산자가 없으면 push)

  → 토큰이 ')'이면 스택 top에 왼쪽 괄호'('가 올 때까지 스택에 pop 연산을 수행하고 pop한 연산자를 출력. '('를 만나면 pop만 하고 출력하지 않는다

  → 중위 표기식에 더 읽을 것이 없다면 중지하고, 있다면 다시 반복

  → 스택에 남아있는 연산자를 모두 pop하여 출력



### 백트래킹



- 미로찾기



### 부분집합

```python
def f(i, N, K):   # i 부분집합에 포함될지 결정할 원소의 인덱스, K는 찾는 합
    if i == N:   # 한개의 부분집합 완성
        s = 0
        for j in range(N):
            if bit[j]:
                s += a[j]
        if s == K:   # 찾는 합이면
            for j in range(N):
                if bit[j]:
                    print(a[j], end=' ')
        print()
    else:
        bit[i] = 1
        f(i+1, N, K)
        bit[i] = 0
        f(i+1, N, K)

a = [1, 2, 3, 4, 5, 6, 7, 8]
bit = [0] * 8
f(0, 3, 10)
```



### 분할 정복





### 퀵 정렬

