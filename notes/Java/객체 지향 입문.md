# 01. 객체와 객체 지향 프로그래밍

## 객체 (Object)

- 의사나 행위가 미치는 대상(사전적 의미)
- 구체적, 추상적 데이터의 단위(학생, 회원, 생산, 주문, 배송)



## 객체 지향 프로그램과 절차 지향 프로그래밍

- 아침에 일어나 학교를 가는 과정을 예를 들어 봅시다.

- 절차 지향 프로그래밍

  - 시간이나 사건의 흐름에 따른 프로그래밍

    일어난다 → 씻는다 →밥을 먹는다 → 버스를 탄다 → 요금을 지불한다 → 학교에 도착

- 객체 지향 프로그래밍



# 02. 생활 속에서 객체 찾아 클래스로 구현해보기

## 객체를 찾아 봅시다

- 온라인 쇼핑몰에 회원 로그인을 하고 여러 판매자가 판매하고 있는 제품 중 하나를 골라 주문한다.
- 아침에 회사에 가는 길에 별다방 커피숍에 들려 아이스 카페라떼를 주문했다.
- 성적확인을 위해 학사 관리 시스템에 로그인하여 수강한 과목들의 성적을 확인했다.



## 클래스는 객체의 청사진(blueprint)입니다

- 객체의 속성은 클래스의 **멤버 변수(member variable)**로 선언함
- 학생 클래스

```java
public class Student {
    
    int studentNumber;
    String studentName;
    int majorCode;
    String majorName;
    int grade;
}
```

- 주문 클래스

```java
public class Order {
    
    int orderId;
    String buyerId;
    String sellerId;
    int productId;
    String orderDate;
}
```

- 회원 클래스

```java
public class Order {
    
    String userId;
    String userPassWord;
    String userName;
    String userAddress;
    int phoneNumber;
}
```



## 객체 지향 프로그램을 할 때는

- 객체를 정의하고
- 각 객체의 속성을 멤버 변수로, 역할을 메서드로 구현하고
- 각 객체간의 협력을 구현합니다.

## 클래스 코딩하기

- 클래스는 대문자로 시작하는 것이 좋음
- java 파일 하나에 클래스는 여러 개가 있을 수 있지만, public 클래스는 하나이고, public 클래스와 .java 파일의 이름은 동일함
- camel notation 방식으로 명명(변수, 메서드)



# 03. 함수와 메서드

## 함수란 (function)

- 하나의 기능을 수행하는 일련의 코드
- 구현된(정의된) 함수는 호출하여 사용하고 호출된 함수는 기능이 끝나면 제어가 반환됨
- 함수로 구현된 하나의 기능은 여러 곳에서 동일한 방식으로 호출되어 사용될 수 있음



## 함수 정의하기

함수는 이름, 매개 변수, 반환값, 함수 몸체(body)로 구성됨

```java
int add(int num1, int num2) {
    
    int result;
    result = num1 + num2;
    return result;
}
```



## 함수 호출과 스택 메모리

- 스택: 함수가 호출될 때 지역 변수들이 사용하는 메모리
- 함수의 수행이 끝나면 자동으로 반환되는 메모리



## 메서드(method)

- 객체의 기능을 구현하기 위해 클래스 내부에 구현되는 함수

- 멤버 함수(member function)이라고도 함(C++에서 주로 사용)

- 메서드를 구현함으로써 객체의 기능이 구현됨

- 메서드의 이름은 그 객체를 사용하는 객체(클라이언트)에 맞게 짓는 것이 좋음

  예) getStudentName()



# 05. 인스턴스 생성과 힙 메모리(heap memory)

## 인스턴스(instance)

- 클래스는 객체의 속성을 정의하고, 기능을 구현하여 만들어 놓은 코드 상태

- 실제 클래스 기반으로 생성도니 객체(인스턴스)는 각각 다른 멤버 변수 값을 가지게 됨

  가령, 학생의 클래스에서 생성된 각각의 인스턴스는 각각 다른 이름, 학번, 학년 등의 값을 가지게 됨

- new 키워드를 사용하여 인스턴스 생성



## 힙 메모리

- 생성된 인스턴스는 동적 메모리(heap memory)에 할당됨
- C나 C++ 언어에서는 사용한 동적 메모리를 프로그래머가 해제시켜야함(free()나 delete 이용)
- 자바에서는 Gabage Collector가 주기적으로 사용하지 않는 메모리를 수거
- 하나의 클래스로부터 여러 개의 인스턴스가 생성되고 각각 다른 메모리 주소를 가지게됨



## 용어 정리

```
객체: 객체 지향 프로그램의 대상, 생성된 인스턴스
클래스: 객체를 프로그래밍 하기 위해 코드로 정의해 놓은 상태
인스턴스: new 키워드를 사용하여 클래스를 메모리에 생성한 상태
멤버 변수: 클래스의 속성, 특성
메서드: 멤버 변수를 이용하여 클래스의 기능을 구현한 함수
참조 변수: 메모리에 생성된 인스턴스를 가리키는 변수
참조값: 생성된 인스턴스의 메모리 주소 값
```



# 06. 생성자(constructor)

## 생성자

- 생성자 기본 문법 <class_name>([argument_list]) {[<statements>]}
- 객체를 생성할 때 new 키워드와 함께 사용 - new Student();
- 생성자는 일반 함수처럼 기능을 호출하는 것이 아니고 객체를 생성하기 위해 new와 함께 호출됨
- 객체가 생성될 때 변수나 상수를 초기화하거나 다른 초기화 기능을 수행하는 메서드를 호출함
- 생성자는 반환값이 없고, 클래스의 이름과 동일
- 대부분의 생성자는 외부에서 접근 가능하지만, 필요에 의해 private으로 선언되는 경우도 있음

## 기본 생성자(default constructor)

- 클래스에는 반드시 적어도 하나 이상의 생성자가 존재

- 클래스에 생성자를 구현하지 않아도 new키워드와 함께 생성자를 호출할 수 있음

- 클래스에 생성자가 하나도 없는 경우 컴파일러가 생성자 코드를 넣어줌

  public Student(){}

- 매개 변수가 없음, 구현부가 없음

## 생성자 만들기

- 컴파일러가 제공해 주는 기본 생성자 외에 필요에 의해 생성자를 직접 구현할 수 있음



# 07. 여러가지 생성자를 정의하는 생성자 오버로딩(overloading)

## 생성자 정의 하기

- 생성자를 구현해서 사용할 수 있음
- 클래스에 생성자를 따로 구현하면 기본 생성자(defalut constructor)는 제공되지 않음
- 생성자를 호출하는 코드(client 코드)에서 여러 생성자 중 필요에 따라 호출해서 사용할 수 있음



# 09. 참조 자료형 변수

## 참조 자료형

- 변수의 자료형
- 클래스형으로 변수를 선언
- 기본 자료형은 사용하는 메모리의 크기가 정해져 있지만, 참조 자료형은 클래스에 따라 다름
- 참조 자료형을 사용할 때는 해당 변수에 대해 생성하여야함(String 클래스는 예외적으로 생성하지 않고 사용할 수 있음)

## 참조 자료형 정의하여 사용하기

- 학생이 수강한 과목들에 대한 성적을 산출하기 위한 경우 학생 클래스 속성에 과목이 모두 있으면 불합리
- 학생(Student)과 과목(Subject)에 대한 클래스를 분리하여 사용하고 Subject클래스를 활용하여 수강한 과목들의 변수의 타입으로 선언
- 선언된 Subject 변수는 생성된 인스턴스가 아니므로 Student의 생성자에서 생성하여 사용



# 10. 접근 제어 지시자(access modifier)와 정보은닉(information hiding)

## 접근 제어 지시자(access modifier)

- 클래스 외부에서 클래스의 멤버 변수, 메서드, 생성자를 사용할 수 있는지 여부를 지정하는 키워드
- private: 같은 클래스 내부에서만 접근 가능(외부 클래스, 상속 관계의 클래스에서도 접근 불가)
- 아무것도 없음(default): 같은 패키지 내부에서만 접근 가능(상속 관계라도 패키지가 다르면 접근 불가)
- protected: 같은 패키지나 상속관계의 클래스에서 접근 가능하고 그 외 외부에서는 접근할 수 없음
- public: 클래스의 외부 어디서나 접근할 수 있음

## get() / set() 메서드

- private으로 선언된 멤버 변수(필드)에 대해 접근, 수정할 수 있는 메서드를 public으로 제공
- get() 메서드만 제공되는 경우 read-only 필드
- 이클립스에서 자동으로 생성됨

## 정보은닉

- private으로 제어한 멤버 변수도 public 메서드가 제공되면 접근 가능하지만 변수가 public으로 공개되었을 때보다 private일 때 각 변수에 대한 제한을 public메서드에서 제어할 수 있다.

```java
public void setMonth(int month) {
    if (month < 1 || month > 12) {
        isValid = false;
    }
    else {
        this.month = month;
    }
}
```

- 객체 지향 프로그램에서 정보 은닉은 필요한 외부에서 접근 가능한 최소한의 정보를 오픈함으로써 객체의 오류를 방지하고 클라이언트 객체가 더 효율적으로 객체를 활용할 수 있도록 해준다.



# 11. 캡슐화(encapsulation)

## 정보 은닉을 활용한 캡슐화

- 꼭 필요한 정보와 기능만 외부에 오픈함
- 대부분의 멤버 변수와 메서드를 외부에 통합된 인터페이스만을 제공하여 일관된 기능을 구현하게 함
- 각각의 메서드나 멤버 변수를 접근함으로써 발생하는 오류를 최소화한다.



# 12. 객체 자신을 가리키는 this

## this가 하는 일

- 인스턴스 자신의 메모리를 가리킴
- 생성자에서 또 다른 생성자를 호출할 때 사용
- 자신의 주소(참조값)를 반환함

## 생성된 인스턴스 메모리의 주소를 가짐



## 생성자에서 다른 생성자를 호출하는 this

- 클래스에 생성자가 여러 개인 경우, this를 이용하여 생성자에서 다른 생성자를 호출할 수 있음
- 생성자에서 다른 생성자를 호출하는 경우, 인스턴스의 생성이 완전하지 않은 상태이므로 this() statement를 쓸 수 없음

```java
public class Person() {
		
    String name;
    int age;
	
    public Person() {
        this("이름없음", 1)
    }
	
	public Person(String name, int age) {
		this.name = name;
		this.age = age;
	}
}
```



## 자신의 주소를 반환하는 this

```java
public class Person() {
		
    String name;
    int age;
	
    public Person() {
        this("이름없음", 1)
    }
	
	public Person(String name, int age) {
		this.name = name;
		this.age = age;
	}
    
    public Person getPerson() {
		return this;
	}
    
    public static void main(String[] args) {
		
		Person p = new Person();
		p.name = "James";
        p.age = 37;

		Person p2 = p.getPerson();
		System.out.println(p);
        System.out.println(p2);
	}
}
```



# 13. 객체 간의 협력(collabration)

## 객체 지향 프로그래밍에서의 협력

- 객체 지향 프로그램에서 객체 간에는 협력이 이루어짐
- 협력을 위해서는 필요한 
